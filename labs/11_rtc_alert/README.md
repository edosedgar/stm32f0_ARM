## Задание 08 "rtc_alert"

### Описание RTC

RTC - real time clock - часы реального времени. Применяются, как ни странно, для того, чтобы поддерживать, насколько возможно, реальное время. Чтобы подерживать ход времени, RTC может продолжать идти даже при выключенном контроллере, но с подключенным питанием Vbat. Примерно для тех же целей у BIOS'а компьютера есть своя батарейка.

На STM32 у модуля RTC есть защита от паразитной записи, которую надо снимать при нужде что-либо изменить в настройках модуля. Так же у модуля RTC есть возможность будить МК, либо генерировать прерывания при определённых событиях (вроде совпадения числа секунд, минут, часов, числа или дня недели с определёнными). Таким образом можно реализовывать в некоторых проектах периодические задачи, которые надо производить, например, раз в день, а всё остальное время спать, чтобы не тратить энергию.

### Настройка RTC

Первым делом подключаем тактирование:

```c
    LL_RCC_LSI_Enable();
    while (LL_RCC_LSI_IsReady() != 1);

    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
    LL_PWR_EnableBkUpAccess(); // для возможности изменять источник тактирования для RTC (сброс настроек RTC)

    LL_RCC_SetRTCClockSource(LL_RCC_RTC_CLKSOURCE_LSI);
    LL_RCC_EnableRTC();
```

В нашем случае мы используем LSI - он не тикает при выключенном контроллере. Для того, чтобы часы шли привыключенном контроллере нужно выбирать LSE и подлючить резонатор на 32.768 kHz - он будет тикать и при выключенным контроллере, но при подключенном питании.

Настройка времени:

```c
	LL_RTC_DisableWriteProtection(RTC);
    LL_RTC_EnableInitMode(RTC); // начало инициализации
    while (!LL_RTC_IsActiveFlag_INIT(RTC));

    LL_RTC_SetAsynchPrescaler(RTC, 0x7F);
    LL_RTC_SetSynchPrescaler(RTC, 0x0137);

    LL_RTC_SetHourFormat(RTC, LL_RTC_HOURFORMAT_24HOUR);
    LL_RTC_DATE_Config(RTC, LL_RTC_WEEKDAY_FRIDAY, 10,
                       LL_RTC_MONTH_MAY, 0x2020);
    LL_RTC_TIME_Config(RTC, LL_RTC_TIME_FORMAT_AM_OR_24, 0x18, 0x30, 00);

    LL_RTC_DisableInitMode(RTC); // конец инициализации - дальше просто часы идут
    LL_RTC_EnableWriteProtection(RTC);
```

Сама настройка обёрнута в функции `LL_RTC_DisableWriteProtection(RTC)` и `LL_RTC_EnableWriteProtection(RTC)` для того, чтобы снять защиту от случайной записи. Настраиваем предделители. В данном случае они настроены так, что после их обоих на выходе получаются нужные для RTC 1Hz. Так же стоит заметить, что все числа в регистрах модуля RTC хранятся в формате BCD: на каждую десятичную цифру уходит 4 бита, т.е. время 18:30 запишется как 0x18 в байт для часов и 0x30 в байт для минут.

Стоит отметить, что эта инициализация происходит при каждом включении МК. То есть каждый запуск будет начинаться для МК в 18:30:00 10 мая 20 года (RTC запоминает только последнии цифры года).

Настройка будильника

```c
    LL_RTC_DisableWriteProtection(RTC);

    LL_RTC_ALMA_Disable(RTC);
    while (!LL_RTC_IsActiveFlag_ALRAW(RTC));
    LL_RTC_ALMA_SetMask(RTC, LL_RTC_ALMA_MASK_ALL);
    LL_RTC_ALMA_Enable(RTC);
    LL_RTC_EnableIT_ALRA(RTC);

    LL_RTC_EnableWriteProtection(RTC);
```

`LL_RTC_ALMA_SetMask(RTC, LL_RTC_ALMA_MASK_ALL)` - выставляет будильник на любое изменение времени (по сути, срабатывает каждую секунду). Изменив маску можно получать сигнал с будилька раз минуту/час/день/неделю/месяц. В таком случае придётся раскомментировать строку с `ConfigTime` и выставить то время, в которое надо, чтобы сработал будильник.

Далее, осталось только включить нужное прерывание в NVIC, учитывая то, что прерывание от RTC на 17 линии EXTI.

### Использование RTC

Во-первых, теперь у нас есть возможность делать что-либо ровно раз в секунду (с точностью до стабильности частоты). В нашем коде, раз в секунду переключается синий светодиод.

Во-вторых, у модуля RTC можно спросить, который сейчас час и какое сегодня число. (Эти числа будут в формате BCD, но есть макросы в библиотеке LL для правильного перевода в обычные числа)

### Дополнительное задание

В качестве задания можно сделать часы с возможностью выставления времени и будильником
